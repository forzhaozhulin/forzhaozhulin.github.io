---
layout: post
title:  "接口回调"
date:   2017-10-29
categories: Java
tags: 接口回调
---

* content
{:toc}
转自[Java回调机制解析](http://blog.csdn.net/bjyfb/article/details/10462555)

# Java回调机制解析

## 回调的含义和用途

---

### 1、什么是回调？

模块之间总是存在这一定的接口，从调用方式上看，可以分为三类：同步调用、回调和异步调用。同步调用是一种阻塞式调用，也是我们在写程序中经常使用的；回调是一种双向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口，这句话可能有点绕，等文章后面举例说明；异步调用是一种类似消息或事件的机制，解决了同步阻塞的问题，举例来讲：A通知B后，他们各走各的路，互不影响，不用像同步调用那样，A通知B后，非得等到B走完后，A才继续走。回调是异步的基本，

### 2、回调的用途

回调一般用于层间协作，上层将本层函数安装在下层，这个函数就是回调，而下层在一定条件下触发回调。例如作为一个驱动，是一个底层，他在收到一个数据时，除了完成本层的处理工作外，还将进行回调，将这个数据交给上层应用层来做进一步处理，这在分层的数据通信中很普遍。

举一个例子，A程序员写了一段程序a，其中预留了回调函数接口，并封装好了该程序，程序员B让a调用自己的程序b中的一个方法，于是，他通过a中的接口回调自己b中的方法；

 有一位老板（上层模块）很忙，他没有时间盯着员工（下层模块）干活，然后他告诉自己的雇员，干完当前这些事情后，告诉他干活的结果。

首先创建一个回调接口，让老板得告知干完活如何找到他的方式：留下老板办公室地址：

```java
/** 
 * 此接口为联系的方式，不论是电话号码还是联系地址，作为 
 * 老板都必须要实现此接口 
 * @author Administrator 
 * 
 */  
public interface CallBackInterface {  
  
    public void execute();  
}  
```

创建回调对象，就是老板本人，因为员工干完活后要给他打电话，因此老板必须实现回调接口，不然员工去哪里找老板？

```java
/** 
 * 老板是作为上层应用身份出现的，下层应用（员工）是不知道 
 * 有哪些方法，因此他想被下层应用（员工）调用必须实现此接口 
 * @author Administrator 
 * 
 */  
public class Boss implements CallBackInterface {  
      
    @Override  
    public void execute() {  
        System.out.println("收到了！！" + System.currentTimeMillis());  
          
    }  
}  
```

创建控制类，也就是员工对象，他必须持有老板的地址（回调接口），即使老板换了一茬又一茬，办公室不变，总能找到对应的老板。

```java
/** 
 * 员工类，必须要记住，这是一个底层类，底层是不了解上层服务的 
 * @author Administrator 
 * 
 */  
public class Employee {  
  
    private CallBackInterface callBack = null;  
      
    //告诉老板的联系方式，也就是注册  
    public void setCallBack(CallBackInterface callBack){  
        this.callBack = callBack;  
    }  
      
    //工人干活  
    public void doSome(){  
        //1.开始干活了  
        for(int i=0;i<10;i++){  
            System.out.println("第【" + i + "】事情干完了！");  
        }  
          
        //2.告诉老板干完了  
        callBack.execute();  
    }  
} 
```

测试类代码：

```java
public class Client {  
  
    public static void main(String[] args) {  
          
          
        Employee emp = new Employee();  
          
        //将回调对象（上层对象）传入，注册  
        emp.setCallBack(new Boss());  
          
        //开启控制器对象运行  
        emp.doSome();  
    }  
  
}  
```

看了上面的例子，有的人可能认为，这不是面向接口的编程吗？怎么会是回调，你再好好想想，咱们面向接口的编程的调用关系？在三层中，当业务层调用数据层时，是不需要把业务层自身传递到数据层的，并且这是一种上层调用下层的关系，比如我们在用框架的时候，一般直接调用框架提供的API就可以了，但回调不同，当框架不能满足需求，我们想让框架来调用自己的类方法，怎么做呢？总不至于去修改框架吧。许多优秀的框架提几乎都供了相关的接口，我们只需要实现相关接口，即可完成了注册，然后在合适的时候让框架来调用我们自己的类，还记不记得我们在使用Struts时，当我们编写Action时，就需要继承Action类，然后实现execute()方法，在execute()方法中写咱们自己的业务逻辑代码，完成对用户请求的处理。由此可以猜测，框架和容器中会提供大量的回调接口，以满足个性化的定制。

要明确的一点是，首先要搞清回调函数出现的原因，也就是适用场景，才能搞清楚回调机制，不然事倍功半。

再举一例，为了使我们写的函数接近完美，就把一部分功能外包给别人，让别人个性化定制，至于别人怎么实现不管，我唯一要做的就是定义好相关接口，`这一设计允许了底层代码调用高层定义的子程序，增强程序灵活性，和反射有着异曲同工之妙`，这才是回调的真正原因！

一段话来总结下回调：上层模块封装时，很难预料下层模块会如何实现，因此，上层模块只需定义好自己需要但不能预料的接口（也就是回调接口），当下层模块调用上层模块时，根据当前需要的实现回调接口，并通过注册或参数方式传入上层模块即可，这样就实现下层调用上层，并且上层还能根据传入的引用来调用下层的具体实现，将程序的灵活性大大的增加了。